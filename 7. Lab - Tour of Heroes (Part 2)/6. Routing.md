_[Adapted from Angular 2 Tour of Heroes](https://angular.io/docs/ts/latest/tutorial/)_

We received new requirements for our Tour of Heroes application:

* Add a *Dashboard* view.
* Navigate between the *Heroes* and *Dashboard* views.
* Clicking on a hero in either view navigates to a detail view of the selected hero.
* Clicking a *deep link* in an email opens the detail view for a particular hero.

When we’re done, users will be able to navigate the app like this:

![View navigations](https://angular.io/resources/images/devguide/toh/nav-diagram.png)

We'll add Angular’s *Router* to our app to satisfy these requirements.

## Where We Left Off

Before we continue with our Tour of Heroes, let’s verify that
we have the following structure after adding our hero service
and hero detail component. If not, we’ll need to go back and follow the previous chapters.

```
angular-tour-of-heroes  
├── app
|   ├── app.component.ts
|   ├── app.module.ts
|   ├── hero.ts
|   ├── hero-detail.component.ts
|   ├── hero.service.ts
|   ├── main.ts
|   ├── mock-heroes.ts
├── node_modules ...
├── index.html
├── package.json
├── styles.css
├── systemjs.config.js
├── tsconfig.json
```

### Keep the app transpiling and running

Open a terminal/console window and enter the following command to
start the TypeScript compiler, start the server, and watch for changes:

```shell
  npm start
```

The application runs and updates automatically as we continue to build the Tour of Heroes.

## Action plan

Here's our plan:

* Turn `AppComponent` into an application shell that only handles navigation
* Relocate the *Heroes* concerns within the current `AppComponent` to a separate `HeroesComponent`
* Add routing
* Create a new `DashboardComponent`
* Tie the *Dashboard* into the navigation structure

> *Routing* is another name for *navigation*. The *router* is the mechanism for navigating from view to view.

## Splitting the *AppComponent*

Our current app loads `AppComponent` and immediately displays the list of heroes.

Our revised app should present a shell with a choice of views (*Dashboard* and *Heroes*)
and then default to one of them.

The `AppComponent` should only handle navigation.
Let's move the display of *Heroes* out of `AppComponent` and into its own `HeroesComponent`.

### *HeroesComponent*

`AppComponent` is already dedicated to *Heroes*.
Instead of moving anything out of `AppComponent`, we'll just rename it `HeroesComponent`
and create a new `AppComponent` shell separately.

The steps are to rename:
* `app.component.ts` file to `heroes.component.ts`
* `AppComponent` class to `HeroesComponent` (rename locally, _only_ in this file)
* Selector `my-app` to `my-heroes`

```TypeScript
@Component({
  selector: 'my-heroes',
})
export class HeroesComponent implements OnInit {
}
```

## Create *AppComponent*

The new `AppComponent` will be the application shell.
It will have some navigation links at the top and a display area below for the pages we navigate to.

The initial steps are:

* Create the file `app/app.component.ts`.
* Define an exported `AppComponent` class.
* Add an `@Component` decorator} above the class with a `my-app` selector
* Move the following from `HeroesComponent` to `AppComponent`:
  * `title` class property
  * `@Component` template `<h1>` element, which contains a binding to  `title`
* Add a `<my-heroes>` element to the app template just below the heading so we still see the heroes.
* Add `HeroesComponent` to the `!{_declsVsDirectives}` array of `!{_AppModuleVsAppComp}` so Angular recognizes the `<my-heroes>` tags.
* Add `HeroService` to the  `providers` array of `!{_AppModuleVsAppComp}` because we'll need it in every other view.
* Remove `HeroService` from the `HeroesComponent` `providers` array since it has been promoted.
* Add the supporting `import` statements for `AppComponent`.

Our first draft looks like this:

```TypeScript
// app/app.component.ts
  import { Component } from '@angular/core';

  @Component({
    selector: 'my-app',
    template: `
      <h1>{{title}}</h1>
      <my-heroes></my-heroes>
    `
  })
  export class AppComponent {
    title = 'Tour of Heroes';
  }
```

```TypeScript
// app/app.module.ts
  import { NgModule }       from '@angular/core';
  import { BrowserModule }  from '@angular/platform-browser';
  import { FormsModule }    from '@angular/forms';
  import { AppComponent }        from './app.component';
  import { HeroDetailComponent } from './hero-detail.component';
  import { HeroesComponent }     from './heroes.component';
  import { HeroService }         from './hero.service';

  @NgModule({
    imports: [
      BrowserModule,
      FormsModule
    ],
    declarations: [
      AppComponent,
      HeroDetailComponent,
      HeroesComponent
    ],
    providers: [
      HeroService
    ],
    bootstrap: [ AppComponent ]
  })
  export class AppModule {
  }
```

The app still runs and still displays heroes.
Our refactoring of `AppComponent` into a new `AppComponent` and a `HeroesComponent` worked!
We have done no harm.

## Add Routing

We're ready to take the next step.
Instead of displaying heroes automatically, we'd like to show them *after* the user clicks a button.
In other words, we'd like to navigate to the list of heroes.

We'll need the Angular *Router*.

>  The Angular router is an external, optional Angular NgModule called `RouterModule`.
  The router is a combination of multiple provided services (`RouterModule`),
  multiple directives (`RouterOutlet, RouterLink, RouterLinkActive`),
  and a configuration (`Routes`). We'll configure our routes first.

### Add the base tag

Open `index.html` and add `<base href="/">` at the top of the `<head>` section.

```html
  <head>
    <base href="/">
```

### Configure routes

Our application doesn't have any routes yet.
We'll start by creating a configuration for the application routes.

*Routes* tell the router which views to display when a user clicks a link or
pastes a URL into the browser address bar.

Let's define our first route as a route to the heroes component:

```TypeScript
// app/app.module.ts
  import { RouterModule }   from '@angular/router';

  RouterModule.forRoot([
    {
      path: 'heroes',
      component: HeroesComponent
    }
  ])
```

The `Routes` are an array of *route definitions*.
We have only one route definition at the moment but rest assured, we'll add more.

This *route definition* has the following parts:

- **path**: the router matches this route's path to the URL in the browser address bar (`heroes`).
- **component**: the component that the router should create when navigating to this route (`HeroesComponent`).

### Make the router available

We've setup the initial route configuration. Now we'll add it to our `AppModule`.
We'll add our configured `RouterModule` to the `AppModule` imports array.

```TypeScript
// app/app.module.ts
  import { NgModule }       from '@angular/core';
  import { BrowserModule }  from '@angular/platform-browser';
  import { FormsModule }    from '@angular/forms';
  import { RouterModule }   from '@angular/router';

  import { AppComponent }        from './app.component';
  import { HeroDetailComponent } from './hero-detail.component';
  import { HeroesComponent }     from './heroes.component';
  import { HeroService }         from './hero.service';

  @NgModule({
    imports: [
      BrowserModule,
      FormsModule,
      RouterModule.forRoot([
        {
          path: 'heroes',
          component: HeroesComponent
        }
      ])
    ],
    declarations: [
      AppComponent,
      HeroDetailComponent,
      HeroesComponent
    ],
    providers: [
      HeroService
    ],
    bootstrap: [ AppComponent ]
  })
  export class AppModule {
  }
```


>  We use the `forRoot` method because we're providing a configured router at the _root_ of the application.
The `forRoot` method gives us the Router service providers and directives needed for routing, and
performs the initial navigation based on the current browser URL.

### Router Outlet

If we paste the path, `/heroes`, into the browser address bar,
the router should match it to the `heroes` route and display the `HeroesComponent`.
But where?

We have to ***tell it where*** by adding a `<router-outlet>` element to the bottom of the template.
`RouterOutlet` is one of the <span if-docs="ts">directives provided by</span> the `RouterModule`.
The router displays each component immediately below the `<router-outlet>` as we navigate through the application.

### Router Links

We don't really expect users to paste a route URL into the address bar.
We add an anchor tag to the template which, when clicked, triggers navigation to the `HeroesComponent`.

The revised template looks like this:

```TypeScript
  template: `
     <h1>{{title}}</h1>
     <a routerLink="/heroes">Heroes</a>
     <router-outlet></router-outlet>
   `
```

Notice the `routerLink` binding in the anchor tag.
We bind the `RouterLink` directive (another of the `RouterModule` directives) to a string that tells the router where to navigate when the user clicks the link.

Since our link is not dynamic, we define a *routing instruction* with a **one-time binding** to our route **path**.
Looking back at the route configuration, we confirm that `'/heroes'` is the path of the route to the `HeroesComponent`.

Refresh the browser.  We see only the app title and heroes link. We don't see the heroes list.

> The browser's address bar shows `/`.
  The route path to `HeroesComponent` is `/heroes`, not `/`.
  We don't have a route that matches the path `/`, so there is nothing to show.
  That's something we'll want to fix.

We click the *Heroes* navigation link, the browser bar updates to `/heroes`,
and now we see the list of heroes. We are navigating at last!

At this stage, our `AppComponent` looks like this.

```TypeScript
// app/app.component.ts

  import { Component } from '@angular/core';
  @Component({
    selector: 'my-app',
    template: `
       <h1>{{title}}</h1>
       <a routerLink="/heroes">Heroes</a>
       <router-outlet></router-outlet>
     `
  })
  export class AppComponent {
    title = 'Tour of Heroes';
  }
```

The  *AppComponent* is now attached to a router and displaying routed views.
For this reason and to distinguish it from other kinds of components,
we call this type of component a *Router Component*.

## Add a *Dashboard*

Routing only makes sense when we have multiple views. We need another view.

Create a placeholder `DashboardComponent` that gives us something to navigate to and from.

```TypeScript
// app/dashboard.component.ts
  import { Component } from '@angular/core';

  @Component({
    selector: 'my-dashboard',
    template: '<h3>My Dashboard</h3>'
  })
  export class DashboardComponent { }
```

We’ll come back and make it more useful later.

### Configure the dashboard route

Go back to `app.module.ts` and teach it to navigate to the dashboard.

Import the dashboard component and
add the following route definition to the `Routes` array of definitions.

```TypeScript
  {
    path: 'dashboard',
    component: DashboardComponent
  },
```

Also import and add `DashboardComponent` to our `AppModule`'s `declarations`.

```TypeScript
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent
  ],
```

#### REDIRECTTO

We want the app to show the dashboard when it starts and
we want to see a nice URL in the browser address bar that says `/dashboard`.
Remember that the browser launches with `/` in the address bar.

We can use a redirect route to make this happen. Add the following
  to our array of route definitions:

```TypeScript
  {
    path: '',
    redirectTo: '/dashboard',
    pathMatch: 'full'
  },
```

#### Add navigation to the template

Finally, add a dashboard navigation link to the template, just above the *Heroes* link.

```TypeScript
  template: `
     <h1>{{title}}</h1>
     <nav>
       <a routerLink="/dashboard">Dashboard</a>
       <a routerLink="/heroes">Heroes</a>
     </nav>
     <router-outlet></router-outlet>
   `
```

> We nested the two links within `<nav>` tags.
  They don't do anything yet but they'll be convenient when we style the links a little later in the chapter.

To see these changes in your browser, go to the application root (`/`) and reload.
The app displays the dashboard and we can navigate between the dashboard and the heroes.

## Dashboard Top Heroes

Let’s spice up the dashboard by displaying the top four heroes at a glance.

Replace the `template` metadata with a `templateUrl` property that points to a new
template file.

Set the `moduleId` property to `module.id` for module-relative loading of the `templateUrl`.

```TypeScript
// app/dashboard.component.ts
  @Component({
    moduleId: module.id,
    selector: 'my-dashboard',
    templateUrl: 'dashboard.component.html',
  })
```

Create that file with this content:

```html
  <h3>Top Heroes</h3>
  <div class="grid grid-pad">
    <div *ngFor="let hero of heroes" class="col-1-4">
      <div class="module hero">
        <h4>{{hero.name}}</h4>
      </div>
    </div>
  </div>
```

We use `*ngFor` once again to iterate over a list of heroes and display their names.
We added extra `<div>` elements to help with styling later in this chapter.

### Share the *HeroService*

We'd like to re-use the `HeroService` to populate the component's `heroes` array.

Recall earlier in the chapter that we removed the `HeroService` from the `providers` array of `HeroesComponent`
and added it to the `providers` array of `AppModule`.

That move created a singleton `HeroService` instance, available to *all* components of the application.
Angular will inject `HeroService` and we'll use it here in the `DashboardComponent`.

### Get heroes

Open `dashboard.component.ts` and add the requisite `import` statements.

```TypeScript
  import { Component, OnInit } from '@angular/core';

  import { Hero } from './hero';
  import { HeroService } from './hero.service';
```

Now implement the `DashboardComponent` class like this:

```TypeScript
  export class DashboardComponent implements OnInit {

    heroes: Hero[] = [];

    constructor(private heroService: HeroService) { }

    ngOnInit(): void {
      this.heroService.getHeroes()
        .then(heroes => this.heroes = heroes.slice(1, 5));
    }
  }
```

We've seen this kind of logic before in the `HeroesComponent`:

* Define a `heroes` array property.
* Inject the `HeroService` in the constructor and hold it in a private `heroService` field.
* Call the service to get heroes inside the Angular `ngOnInit` lifecycle hook.

In this dashboard we cherry-pick four heroes (2nd, 3rd, 4th, and 5th) with the `Array.slice` method.

Refresh the browser and see four heroes in the new dashboard.

## Navigate to Hero Details

Although we display the details of a selected hero at the bottom of the `HeroesComponent`,
we don't yet *navigate* to the `HeroDetailComponent` in the three ways specified in our requirements:

1. from the *Dashboard* to a selected hero.
1. from the *Heroes* list to a selected hero.
1. from a "deep link" URL pasted into the browser address bar.

Adding a hero-detail route seems like an obvious place to start.

### Routing to a hero detail

We'll add a route to the `HeroDetailComponent` in `app.module.ts` where our other routes are configured.

The new route is a bit unusual in that we must tell the `HeroDetailComponent` *which hero to show*.
We didn't have to tell the `HeroesComponent` or the `DashboardComponent` anything.

At the moment the parent `HeroesComponent` sets the component's `hero` property to a
hero object with a binding like this.

```html
  <my-hero-detail [hero]="selectedHero"></my-hero-detail>
```

That clearly won't work in any of our routing scenarios.
Certainly not the last one; we can't embed an entire hero object in the URL! Nor would we want to.

### Parameterized route

We *can* add the hero's `id` to the URL. When routing to the hero whose `id` is 11,
we could expect to see a URL such as this:

```
  /detail/11
```

The `/detail/` part of that URL is constant. The trailing numeric `id` part changes from hero to hero.
We need to represent that variable part of the route with a *parameter* (or *token*) that stands for the hero's `id`.

### Configure a Route with a Parameter

Here's the *route definition* we'll use.

```TypeScript
  {
    path: 'detail/:id',
    component: HeroDetailComponent
  },
```

The colon (:) in the path indicates that `:id` is a placeholder to be filled with a specific hero `id`
when navigating to the `HeroDetailComponent`.

We're finished with the application routes.

We won't add a `'Hero Detail'` link to the template because users
don't click a navigation *link* to view a particular hero.
They click a *hero* whether that hero is displayed on the dashboard or in the heroes list.

We'll get to those *hero* clicks later in the chapter.
There's no point in working on them until the `HeroDetailComponent`
is ready to be navigated *to*.

That will require an `HeroDetailComponent` overhaul.

## Revise the *HeroDetailComponent*

Before we rewrite the `HeroDetailComponent`, let's review what it looks like now:

```TypeScript
// app/hero-detail.component.ts
  import { Component, Input } from '@angular/core';
  import { Hero } from './hero';

  @Component({
    selector: 'my-hero-detail',
    template: `
      <div *ngIf="hero">
        <h2>{{hero.name}} details!</h2>
        <div>
          <label>id: </label>{{hero.id}}
        </div>
        <div>
          <label>name: </label>
          <input [(ngModel)]="hero.name" placeholder="name"/>
        </div>
      </div>
    `
  })
  export class HeroDetailComponent {
    @Input() hero: Hero;
  }
```

The template won't change. We'll display a hero the same way.
The big changes are driven by how we get the hero.

We will no longer receive the hero in a parent component property binding. The new `HeroDetailComponent` should take the `id` parameter from the `params` observable in the `ActivatedRoute` service and use the `HeroService` to fetch the hero with that `id`.

First, add the requisite imports:

```TypeScript
  // Keep the Input import for now, we'll remove it later:
  import { Component, Input, OnInit } from '@angular/core';
  import { ActivatedRoute, Params }   from '@angular/router';
  import { Location }                 from '@angular/common';

  import { HeroService } from './hero.service';
```

Let's have the `ActivatedRoute` service, the `HeroService` and the `Location` service injected
into the constructor, saving their values in private fields:

```TypeScript
  constructor(
    private heroService: HeroService,
    private route: ActivatedRoute,
    private location: Location
  ) {}
```

Also import the `switchMap` operator to use later with the route parameters `Observable`.

```TypeScript
  import 'rxjs/add/operator/switchMap';
```

We tell the class that we want to implement the `OnInit` interface.

```TypeScript
  export class HeroDetailComponent implements OnInit {
```

Inside the `ngOnInit` lifecycle hook, we use the `params` observable to
  extract the `id` parameter value from the `ActivatedRoute` service
  and use the `HeroService` to fetch the hero with that `id`.

```TypeScript
  ngOnInit(): void {
    this.route.params
      .switchMap((params: Params) => this.heroService.getHero(+params['id']))
      .subscribe(hero => this.hero = hero);
  }
```

Note how the `switchMap` operator maps the id in the observable route parameters
to a new `Observable`, the result of the `HeroService.getHero` method.

If the user re-navigates to this component while a getHero request is still inflight,
switchMap cancels that old request before calling `HeroService.getHero` again.

The hero `id` is a number. Route parameters are *always strings*.
So we convert the route parameter value to a number with the JavaScript (+) operator.

> ### Do I need to unsubscribe?

>  The `Router` manages the observables it provides and localizes
the subscriptions. The subscriptions are cleaned up when the component is destroyed, protecting against
memory leaks, so we don't need to _unsubscribe_ from the route params `Observable`.

### Add *HeroService.getHero*

The problem with this bit of code is that `HeroService` doesn't have a `getHero` method!
We better fix that quickly before someone notices that we broke the app.

Open `HeroService` and add a `getHero` method that filters the heroes list from `getHeroes` by `id`:

```TypeScript
  getHero(id: number): Promise<Hero> {
    return this.getHeroes()
               .then(heroes => heroes.find(hero => hero.id === id));
  }
```

Let's return to the `HeroDetailComponent` to clean up loose ends.

### Find our way back

We can navigate *to* the `HeroDetailComponent` in several ways.
How do we navigate somewhere else when we're done?

The user could click one of the two links in the `AppComponent`. Or click the browser's back button.
We'll add a third option, a `goBack` method that navigates backward one step in the browser's history stack
using the `Location` service we injected previously.

```TypeScript
  goBack(): void {
    this.location.back();
  }
```

> Going back too far could take us out of the application.
That's acceptable in a demo. We'd guard against it in a real application,
perhaps with the `CanDeactivate` guard.

Then we wire this method with an event binding to a *Back* button that we
add to the bottom of the component template.

```html
  <button (click)="goBack()">Back</button>
```

Modifying the template to add this button spurs us to take one more
incremental improvement and migrate the template to its own file,
called `hero-detail.component.html`:

```html
  <div *ngIf="hero">
    <h2>{{hero.name}} details!</h2>
    <div>
      <label>id: </label>{{hero.id}}</div>
    <div>
      <label>name: </label>
      <input [(ngModel)]="hero.name" placeholder="name" />
    </div>
    <button (click)="goBack()">Back</button>
  </div>
```

We update the component metadata with a `moduleId` and a `templateUrl` pointing to the template file that we just created.

```TypeScript
@Component({
  moduleId: module.id,
  selector: 'my-hero-detail',
  templateUrl: 'hero-detail.component.html',
})

```

:marked
Refresh the browser and see the results.

.l-main-section
:marked
## Select a *Dashboard* Hero

When a user selects a hero in the dashboard, the app should navigate to the `HeroDetailComponent` to view and edit the selected hero.

Although the dashboard heroes are presented as button-like blocks, they should behave like anchor tags.
When hovering over a hero block, the target URL should display in the browser status bar
and the user should be able to copy the link or open the hero detail view in a new tab.

To achieve this effect, reopen the `dashboard.component.html` and replace the repeated `<div *ngFor...>` tags
with `<a>` tags. The opening `<a>` tag looks like this:

```html
  <a *ngFor="let hero of heroes"  [routerLink]="['/detail', hero.id]"  class="col-1-4">
```

Notice the `[routerLink]` binding.

Top level navigation in the [`AppComponent`
template](#router-links) has router links set to fixed !{_pathVsName}s of the
destination routes, "/dashboard" and "/heroes".

This time, we're binding to an expression containing a **link parameters array**.
The array has two elements, the ***path*** of
the destination route and a ***route parameter*** set to the value of the current hero's `id`.

The two array items align with the ***path*** and ***:id***
token in the parameterized hero detail route definition we added to
`app.module.ts` earlier in the chapter:

```TypeScript
  {
    path: 'detail/:id',
    component: HeroDetailComponent
  },
```

Refresh the browser and select a hero from the dashboard; the app should navigate directly to that hero’s details.

## Refactor routes to a _Routing Module_

Almost 20 lines of `AppModule` are devoted to configuring four routes.
Most applications have many more routes and they add guard services
to protect against unwanted or unauthorized navigations.
Routing considerations could quickly dominate this module and obscure its primary purpose which is to
establish key facts about the entire app for the Angular compiler.

We should refactor the routing configuration into its own class.
What kind of class?
The current `RouterModule.forRoot()` produces an Angular `ModuleWithProviders` which suggests that a
class dedicated to routing should be some kind of module.
It should be a _Routing Module_.

By convention the name of a _Routing Module_ contains the word "Routing" and
aligns with the name of the module that declares the components navigated to.

Create an `app-routing.module.ts` file as a sibling to `app.module.ts`. Give it the following contents extracted from the `AppModule` class:

```TypeScript
  import { NgModule }             from '@angular/core';
  import { RouterModule, Routes } from '@angular/router';
  import { DashboardComponent }   from './dashboard.component';
  import { HeroesComponent }      from './heroes.component';
  import { HeroDetailComponent }  from './hero-detail.component';

  const routes: Routes = [
    { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
    { path: 'dashboard',  component: DashboardComponent },
    { path: 'detail/:id', component: HeroDetailComponent },
    { path: 'heroes',     component: HeroesComponent }
  ];
  @NgModule({
    imports: [ RouterModule.forRoot(routes) ],
    exports: [ RouterModule ]
  })
  export class AppRoutingModule {}
```

Noteworthy points, typical of _Routing Modules_:
* Pulls the routes into a variable. You might export it in future and it clarifies the _Routing Module_ pattern.

* Adds `RouterModule.forRoot(routes)` to `imports`.

* Adds `RouterModule` to `exports` so that the components in the companion module have access to Router declarables
such as `RouterLink` and `RouterOutlet`.

* No `declarations`!  Declarations are the responsibility of the companion module.

* Adds module `providers` for guard services if you have them; there are none in this example.

### Update _AppModule_

Now delete the routing configuration from `AppModule` and import the `AppRoutingModule`
(_both_ with an ES `import` statement _and_ by adding it to the `NgModule.imports` list).

Here is the revised `AppModule`, compared to its pre-refactor state:

```TypeScript
// before
  import { NgModule }       from '@angular/core';
  import { BrowserModule }  from '@angular/platform-browser';
  import { FormsModule }    from '@angular/forms';
  import { RouterModule }   from '@angular/router';
  import { AppComponent }        from './app.component';
  import { HeroDetailComponent } from './hero-detail.component';
  import { DashboardComponent }  from './dashboard.component';
  import { HeroesComponent }     from './heroes.component';
  import { HeroService }         from './hero.service';

  @NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot([
      {
        path: '',
        redirectTo: '/dashboard',
        pathMatch: 'full'
      },
      {
        path: 'dashboard',
        component: DashboardComponent
      },
      {
        path: 'detail/:id',
        component: HeroDetailComponent
      },
      {
        path: 'heroes',
        component: HeroesComponent
      }
    ])
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent
  ],
  providers: [
    HeroService
  ],
  bootstrap: [ AppComponent ]
  })
  export class AppModule {
  }

```

```TypeScript
// after
  import { NgModule }       from '@angular/core';
  import { BrowserModule }  from '@angular/platform-browser';
  import { FormsModule }    from '@angular/forms';
  import { AppComponent }         from './app.component';
  import { DashboardComponent }   from './dashboard.component';
  import { HeroDetailComponent }  from './hero-detail.component';
  import { HeroesComponent }      from './heroes.component';
  import { HeroService }          from './hero.service';
  import { AppRoutingModule }     from './app-routing.module';

  @NgModule({
    imports: [
      BrowserModule,
      FormsModule,
      AppRoutingModule
    ],
    declarations: [
      AppComponent,
      DashboardComponent,
      HeroDetailComponent,
      HeroesComponent
    ],
    providers: [ HeroService ],
    bootstrap: [ AppComponent ]
  })
  export class AppModule { }
```

It's simpler and focused on identifying the key pieces of the application.

## Select a Hero in the *HeroesComponent*

Earlier we added the ability to select a hero from the dashboard.
We'll do something similar in the `HeroesComponent`.

The `HeroesComponent` template exhibits a "master/detail" style with the list of heroes
at the top and details of the selected hero below.

```html
  template: `
    <h1>{{title}}</h1>
    <h2>My Heroes</h2>
    <ul class="heroes">
      <li *ngFor="let hero of heroes"
        [class.selected]="hero === selectedHero"
        (click)="onSelect(hero)">
        <span class="badge">{{hero.id}}</span> {{hero.name}}
      </li>
    </ul>
    <my-hero-detail [hero]="selectedHero"></my-hero-detail>
  `,
```

Our goal is to move the detail to its own view and navigate to it when the user decides to edit a selected hero.

Delete the `<h1>` at the top (we forgot about it during the `AppComponent`-to-`HeroesComponent` conversion).

Delete the last line of the template with the `<my-hero-detail>` tags.

We'll no longer show the full `HeroDetailComponent` here.
We're going to display the hero detail on its own page and route to it as we did in the dashboard.

We'll throw in a small twist for variety.
We are keeping the "master/detail" style but shrinking the detail to a "mini", read-only version.
When the user selects a hero from the list, we *don't* go to the detail page.
We show a *mini-detail* on *this* page instead and make the user click a button to navigate to the *full detail *page.

### Add the *mini-detail*

Add the following HTML fragment at the bottom of the template where the `<my-hero-detail>` used to be:

```html
  <div *ngIf="selectedHero">
    <h2>
      {{selectedHero.name | uppercase}} is my hero
    </h2>
    <button (click)="gotoDetail()">View Details</button>
  </div>
```

After clicking a hero, the user should see something like this below the hero list:

![Mini Hero Detail](https://angular.io/resources/images/devguide/toh/mini-hero-detail.png)

### Format with the *uppercase* pipe

Notice that the hero's name is displayed in CAPITAL LETTERS. That's the effect of the `uppercase` pipe
that we slipped into the interpolation binding. Look for it right after the pipe operator ( | ).

```
  {{selectedHero.name | uppercase}} is my hero
```

Pipes are a good way to format strings, currency amounts, dates and other display data.
Angular ships with several pipes and we can write our own.

### Move content out of the component file

We are not done. We still have to update the component class to support navigation to the
`HeroDetailComponent` when the user clicks the *View Details* button.

This component file is really big. Most of it is either template or CSS styles.
It's difficult to find the component logic amidst the noise of HTML and CSS.

Let's migrate the template and the styles to their own files before we make any more changes:

1. *Cut-and-paste* the template contents into a new <span ngio-ex>heroes.component.html</span> file.
1. *Cut-and-paste* the styles contents into a new <span ngio-ex>heroes.component.css</span> file.
1. *Set* the component metadata's `templateUrl` and `styleUrls` properties to refer to both files.
1. *Set* the `moduleId` property to `module.id` so that `templateUrl` and `styleUrls` are relative to the component.

The `styleUrls` property is !{_an} array of style file names (with paths).
We could list multiple style files from different locations if we needed them.

```TypeScript
  @Component({
    moduleId: module.id,
    selector: 'my-heroes',
    templateUrl: 'heroes.component.html',
    styleUrls: [ 'heroes.component.css' ]
  })
```

### Update the _HeroesComponent_ class.

The `HeroesComponent` navigates to the `HeroDetailComponent` in response to a button click.
The button's _click_ event is bound to a `gotoDetail` method that navigates _imperatively_
by telling the router where to go.

This approach requires some changes to the component class:

1. Import the `router` from the Angular router library
1. Inject the `router` in the constructor (along with the `HeroService`)
1. Implement `gotoDetail` by calling the `router.navigate` method

```TypeScript
  gotoDetail(): void {
    this.router.navigate(['/detail', this.selectedHero.id]);
  }
```

Note that we're passing a two-element **link parameters array**
&mdash; a path and the route parameter &mdash; to
the `router.navigate` method just as we did in the `[routerLink]` binding
back in the `DashboardComponent`.
Here's the fully revised `HeroesComponent` class:

```TypeScript
  export class HeroesComponent implements OnInit {
    heroes: Hero[];
    selectedHero: Hero;

    constructor(
      private router: Router,
      private heroService: HeroService) { }

    getHeroes(): void {
      this.heroService.getHeroes().then(heroes => this.heroes = heroes);
    }

    ngOnInit(): void {
      this.getHeroes();
    }

    onSelect(hero: Hero): void {
      this.selectedHero = hero;
    }

    gotoDetail(): void {
      this.router.navigate(['/detail', this.selectedHero.id]);
    }
  }
```

Refresh the browser and start clicking.
We can navigate around the app, from the dashboard to hero details and back,
for heroes list to the mini-detail to the hero details and back to the heroes again.
We can jump back and forth between the dashboard and the heroes.

We've met all of the navigational requirements that propelled this chapter.

## Styling the App

The app is functional but pretty ugly.
Our creative designer team provided some CSS files to make it look better.

### A Dashboard with Style

The designers think we should display the dashboard heroes in a row of rectangles.
They've given us ~60 lines of CSS for this purpose including some simple media queries for responsive design.

If we paste these ~60 lines into the component `styles` metadata,
they'll completely obscure the component logic.
Let's not do that. It's easier to edit CSS in a separate `*.css` file anyway.

Add a <span ngio-ex>dashboard.component.css</span> file to the `!{_appDir}` folder and reference
that file in the component metadata's `styleUrls` array property like this:

```
styleUrls: [ 'dashboard.component.css' ]
```

### Stylish Hero Details

The designers also gave us CSS styles specifically for the `HeroDetailComponent`.

Add a `hero-detail.component.css` to the `app`
folder and refer to that file inside
the `styleUrls` array as we did for `DashboardComponent`.
Let's also remove the `hero` property `@Input` decorator
and its import while we are at it.

Here's the content for the aforementioned component CSS files.

```css
/* app/hero-detail.component.css */
  label {
    display: inline-block;
    width: 3em;
    margin: .5em 0;
    color: #607D8B;
    font-weight: bold;
  }
  input {
    height: 2em;
    font-size: 1em;
    padding-left: .4em;
  }
  button {
    margin-top: 20px;
    font-family: Arial;
    background-color: #eee;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer; cursor: hand;
  }
  button:hover {
    background-color: #cfd8dc;
  }
  button:disabled {
    background-color: #eee;
    color: #ccc;
    cursor: auto;
  }
```

```css
/*  app/dashboard.component.css` */
  [class*='col-'] {
    float: left;
    padding-right: 20px;
    padding-bottom: 20px;
  }
  [class*='col-']:last-of-type {
    padding-right: 0;
  }
  a {
    text-decoration: none;
  }
  *, *:after, *:before {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
  }
  h3 {
    text-align: center; margin-bottom: 0;
  }
  h4 {
    position: relative;
  }
  .grid {
    margin: 0;
  }
  .col-1-4 {
    width: 25%;
  }
  .module {
    padding: 20px;
    text-align: center;
    color: #eee;
    max-height: 120px;
    min-width: 120px;
    background-color: #607D8B;
    border-radius: 2px;
  }
  .module:hover {
    background-color: #EEE;
    cursor: pointer;
    color: #607d8b;
  }
  .grid-pad {
    padding: 10px 0;
  }
  .grid-pad > [class*='col-']:last-of-type {
    padding-right: 20px;
  }
  @media (max-width: 600px) {
    .module {
      font-size: 10px;
      max-height: 75px; }
  }
  @media (max-width: 1024px) {
    .grid {
      margin: 0;
    }
    .module {
      min-width: 60px;
    }
  }
```

### Style the Navigation Links

The designers gave us CSS to make the navigation links in our `AppComponent` look more like selectable buttons.
We cooperated by surrounding those links in `<nav>` tags.

Add a `app.component.css` file to the `app` folder with the following content.

```css
/* app/app.component.css */
  h1 {
    font-size: 1.2em;
    color: #999;
    margin-bottom: 0;
  }
  h2 {
    font-size: 2em;
    margin-top: 0;
    padding-top: 0;
  }
  nav a {
    padding: 5px 10px;
    text-decoration: none;
    margin-top: 10px;
    display: inline-block;
    background-color: #eee;
    border-radius: 4px;
  }
  nav a:visited, a:link {
    color: #607D8B;
  }
  nav a:hover {
    color: #039be5;
    background-color: #CFD8DC;
  }
  nav a.active {
    color: #039be5;
  }

```

> **The *routerLinkActive* directive**

> The Angular Router provides a `routerLinkActive` directive we can use to
  add a class to the HTML navigation element whose route matches the active route.
  All we have to do is define the style for it. Sweet!

> ```html
    template: `
      <h1>{{title}}</h1>
      <nav>
        <a routerLink="/dashboard" routerLinkActive="active">Dashboard</a>
        <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
      </nav>
      <router-outlet></router-outlet>
    `,
  ```  

First add `moduleId: module.id` to the `@Component` metadata of the `AppComponent`
to enable _module-relative_ file URLs.
Then add a `styleUrls` property that points to this CSS file as follows.

```
  styleUrls: ['app.component.css'],
```

### Global application styles

When we add styles to a component, we're keeping everything a component needs
&mdash; HTML, the CSS, the code &mdash; together in one convenient place.
It's pretty easy to package it all up and re-use the component somewhere else.

We can also create styles at the *application level* outside of any component.

Our designers provided some basic styles to apply to elements across the entire app.
These correspond to the full set of master styles that we installed earlier during [setup](../guide/setup.html).
Here is an excerpt:

```css
/* styles.css */
  /* Master Styles */
  h1 {
    color: #369;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 250%;
  }
  h2, h3 {
    color: #444;
    font-family: Arial, Helvetica, sans-serif;
    font-weight: lighter;
  }
  body {
    margin: 2em;
  }
  body, input[text], button {
    color: #888;
    font-family: Cambria, Georgia;
  }
  /* . . . */
  /* everywhere else */
  * {
    font-family: Arial, Helvetica, sans-serif;
  }
```

Create the file `styles.css`, if it doesn't exist already.

If necessary, also edit `index.html` to refer to this stylesheet.

```html
  <link rel="stylesheet" href="styles.css">
```

Look at the app now. Our dashboard, heroes, and navigation links are styling!

![View navigations](https://angular.io/resources/images/devguide/toh/dashboard-top-heroes.png)

## Application structure and code

Review the sample source code in the <live-example></live-example> for this chapter.
Verify that we have the following structure:

```
angular-tour-of-heroes  
├── app
|   ├── app.component.css
|   ├── app.component.ts
|   ├── app.module.ts
|   ├── app-routing.module.ts
|   ├── dashboard.component.css
|   ├── dashboard.component.html
|   ├── dashboard.component.ts
|   ├── hero.service.ts
|   ├── hero.ts
|   ├── hero-detail.component.css
|   ├── hero-detail.component.html
|   ├── hero-detail.component.ts
|   ├── heroes.component.css
|   ├── heroes.component.html
|   ├── heroes.component.ts
|   ├── main.ts
├── node_modules ...
├── index.html
├── package.json
├── styles.css
├── systemjs.config.js
├── tsconfig.json
```

## Recap

### The Road Behind

We travelled a great distance in this chapter

- We added the Angular *Router* to navigate among different components.
- We learned how to create router links to represent navigation menu items.
- We used router link parameters to navigate to the details of user selected hero.
- We shared the `HeroService` among multiple components.
- We moved HTML and CSS out of the component file and into their own files.
- We added the `uppercase` pipe to format data.
- We refactored routes into a `Routing Module` that we import.
